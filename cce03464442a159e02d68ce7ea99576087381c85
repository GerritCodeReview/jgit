{
  "comments": [
    {
      "key": {
        "uuid": "5202edb4_b57110a8",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/reftable/ReftableCompactor.java",
        "patchSetId": 1
      },
      "lineNbr": 192,
      "author": {
        "id": 129259
      },
      "writtenOn": "2020-01-29T00:05:56Z",
      "side": 1,
      "message": "These update indices come from the setters, while the writer in line 157 and 158 uses indices from the reader. Should they be consistent?",
      "range": {
        "startLine": 192,
        "startChar": 8,
        "endLine": 192,
        "endChar": 68
      },
      "revId": "cce03464442a159e02d68ce7ea99576087381c85",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "09fb0ae5_deb2d77e",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/reftable/ReftableCompactor.java",
        "patchSetId": 1
      },
      "lineNbr": 192,
      "author": {
        "id": 98905
      },
      "writtenOn": "2020-01-29T14:03:41Z",
      "side": 1,
      "message": "No, I don\u0027t think so.  in l.157, 158 we set the update_index that we use for delta compressing ref updates. For the compacted table to be valid in its stack, we have to copy the range of update indices. this previously happened in l.192 (see above).\n\nHowever, this meant that reflog entries could be dropped -  for example,    \n\n  https://eclipse.googlesource.com/jgit/jgit/+/refs/heads/master/Documentation/technical/reftable.md#log-record\n\nsays \n\n\"The log_type \u003d 0x0 is mostly useful for git stash drop, removing an entry from the reflog of refs/stash in a transaction file (below), without needing to rewrite larger files. Readers reading a stack of reflogs must treat this as a deletion.\"\n\nif you delete an existing log entry, by definition, you\u0027d write it at an update_index outside of the range of the table you\u0027re writing. This would cause it to be (erroneously) deleted on the next compaction.\n\nit took a while before I understood this finesse, and now it\u0027s also not obvious to you from this code, so I should add a test.",
      "parentUuid": "5202edb4_b57110a8",
      "range": {
        "startLine": 192,
        "startChar": 8,
        "endLine": 192,
        "endChar": 68
      },
      "revId": "cce03464442a159e02d68ce7ea99576087381c85",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3cbc18e3_cc76a43b",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/reftable/ReftableCompactor.java",
        "patchSetId": 1
      },
      "lineNbr": 192,
      "author": {
        "id": 98905
      },
      "writtenOn": "2020-01-29T18:15:12Z",
      "side": 1,
      "message": "I tried writing a test, but it\u0027s actually hard.\n\nHere is the scenario where the original code would do something wrong:\n\nwrite a bunch of log entries\n\n  \"branch @ 0\" - reftable 0-0   // minUpdateIdx \u003d 0, maxUpdateIdx \u003d 0\n  \"branch @ 1\" - reftable 1-1\n  \"branch @ 2\" - reftable 2-2\n  \"branch @ 3\" - reftable 3-3\n\nnow issue a tombstone for the first entry: \n\n  \"DELETE branch @ 0\" - reftable 4-4  \n\nNow imagine we run a compaction of the last 2 tables, ie.\n\n  \"branch @ 3\" - reftable 3-3\n  \"DELETE branch @ 0\" - reftable 4-4  \n\nThe previous code would set min\u003d3, max\u003d4 and then throw out the DELETE entry on compaction.\n\nIt\u0027s hard to test because the deletion logic is in the spec, but it is not exposed in JGit, and the API doesn\u0027t allow the amount of control to create just that compaction that would create a problem.",
      "parentUuid": "09fb0ae5_deb2d77e",
      "range": {
        "startLine": 192,
        "startChar": 8,
        "endLine": 192,
        "endChar": 68
      },
      "revId": "cce03464442a159e02d68ce7ea99576087381c85",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
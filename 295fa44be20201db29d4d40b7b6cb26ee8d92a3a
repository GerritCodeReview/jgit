{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c33a4764_9563b917",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/revwalk/RevCommit.java",
        "patchSetId": 41
      },
      "lineNbr": 147,
      "author": {
        "id": 201156
      },
      "writtenOn": "2022-12-19T21:08:44Z",
      "side": 1,
      "message": "This explicit #parseHeadersInGraph() muddles the life-cycle of RevCommit. e.g. It is not obvious what happens if you invoke #parseHeaders() and then #parseHeadersInGraph() (or the other way around). Or why should the caller care if the data comes from graph or pack?\n\nThis would be clearer to implement in a subclass of RevCommit (eg. RevCommitCG). A RevCommitCG IS-A RevCommit with a graph position.\n\nThen RevCommitCG would keep the same life-cycle than RevCommit, only that #parseHeaders would read from the commit-graph, instead of the pack.\n \nRevCommitCG could be instantiated in RevWalk#createCommit(), which chooses between RevCommit/RevCommitCG depending if the requested commit is in the graph.\n\nWith a subclass, any current usage of RevWalk using only the headers would benefit from the commit graph without change. It also keeps the API of RevCommit consistent.\n\nAlternatively, this could be an \"if\" inside #parseHeaders() but then we pay the int of the graph position for every RevCommit instance (even when there is no graph) and make more complicated the parsing (for a case that looks pretty well fitted for overriding).",
      "revId": "295fa44be20201db29d4d40b7b6cb26ee8d92a3a",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2afec28_a84809e9",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/revwalk/RevCommit.java",
        "patchSetId": 41
      },
      "lineNbr": 147,
      "author": {
        "id": 304466
      },
      "writtenOn": "2022-12-20T07:37:09Z",
      "side": 1,
      "message": "\u003e This explicit #parseHeadersInGraph() muddles the life-cycle of RevCommit. e.g. It is not obvious what happens if you invoke #parseHeaders() and then #parseHeadersInGraph() (or the other way around). Or why should the caller care if the data comes from graph or pack?\n\nIf RevWalk#isRetainBody() is false, #parseHeadersInGraph() can cover all informations of #parseHeaders() and contains additional graphPos and generation.\n\n1. If we call #parseHeaders() and then #parseHeadersInGraph(), RevWalk will try to add graphPos and generation informations if commit is in commit-graph.\n\n2. If we call #parseHeadersInGraph() and then #parseHeaders(), commit will not have any changes.\n\n\u003e \n\u003e This would be clearer to implement in a subclass of RevCommit (eg. RevCommitCG). A RevCommitCG IS-A RevCommit with a graph position.\n\u003e \n\u003e Then RevCommitCG would keep the same life-cycle than RevCommit, only that #parseHeaders would read from the commit-graph, instead of the pack.\n\u003e  \n\u003e RevCommitCG could be instantiated in RevWalk#createCommit(), which chooses between RevCommit/RevCommitCG depending if the requested commit is in the graph.\n\u003e \n\u003e With a subclass, any current usage of RevWalk using only the headers would benefit from the commit graph without change. It also keeps the API of RevCommit consistent.\n\u003e \n\u003e Alternatively, this could be an \"if\" inside #parseHeaders() but then we pay the int of the graph position for every RevCommit instance (even when there is no graph) and make more complicated the parsing (for a case that looks pretty well fitted for overriding).\n\nYou means \"RevCommitCG extends RevCommit\"?\nI\u0027ve thought about this before, but it also brings some new problems:\n\n1.  If we still use RevWalk to generate RevCommitCG, whenever we want to obtain graphPos or generation information, we need to add addtional \"instead of RevCommitCG\" statement for judgment. \nIt can be avoided if we add a default value to RevCommit#getGeneration(), but in this case, it feels that subclass does not make much sense.\nOf course, we also need to consider the issues I mentioned above[1] about RevCommit instance reuse in RevWalk#objects.\n\n2. If we refer to the code of DepthWalk, use a subclass of RevWalk (eg. CGRevWalk) to generate RevCommitCG. In this way, it feels like implementing a RevWalk v2 version, which can cover all the features of RevWalk. \nThen users need to replace all RevWalk in their own code with CGRevWalk to enjoy the acceleration of commit-graph, which will bring a lot of work.\n\n[1] https://git.eclipse.org/r/c/jgit/jgit/+/183079/comments/bc0f78e5_3347850e",
      "parentUuid": "c33a4764_9563b917",
      "revId": "295fa44be20201db29d4d40b7b6cb26ee8d92a3a",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b735edde_94d06e9b",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/revwalk/RevCommit.java",
        "patchSetId": 41
      },
      "lineNbr": 147,
      "author": {
        "id": 304466
      },
      "writtenOn": "2022-12-21T02:56:09Z",
      "side": 1,
      "message": "\u003e 1.  If we still use RevWalk to generate RevCommitCG, whenever we want to obtain graphPos or generation information, we need to add addtional \"instead of RevCommitCG\" statement for judgment. \n\ntypo:  \"instead of RevCommitCG\" -\u003e \"instanceof RevCommitCG\"",
      "parentUuid": "c2afec28_a84809e9",
      "revId": "295fa44be20201db29d4d40b7b6cb26ee8d92a3a",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "795dfdd9_63756126",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/revwalk/RevCommit.java",
        "patchSetId": 41
      },
      "lineNbr": 147,
      "author": {
        "id": 201156
      },
      "writtenOn": "2023-01-03T23:24:30Z",
      "side": 1,
      "message": "\u003e You means \"RevCommitCG extends RevCommit\"?\n\nRight\n\n\u003e 1.  If we still use RevWalk to generate RevCommitCG, whenever we want to obtain graphPos or generation information, we need to add addtional \"instead of RevCommitCG\" statement for judgment. \n\u003e It can be avoided if we add a default value to RevCommit#getGeneration(), but in this case, it feels that subclass does not make much sense.\n\nAs a concept, it is easy to reason that a RevCommitCG is a RevCommit loading its data from a different source. You can replace one with the other and the caller doesn\u0027t need to know. This maps cleanly into a subclass.\n\nFrom the caller point of view, why do they need to know about the graph (#parseInGraph())? Callers just indicate \"I will access headers\" with #parseHeaders and where do those headers come from is irrelevant for them. \n\nPlus any existing code would benefit from the commit-graph without further change.\n\n\u003e Of course, we also need to consider the issues I mentioned above[1] about RevCommit instance reuse in RevWalk#objects.\n\nThe instances are still created/kept by the RevWalk (not in the commit graph), e.g. in RevWalk#createCommit() so all that is the same.\n\nNot sure what do you mean in #2. We dont need to subclass RevWalk. DepthWalk.Commit maybe needs some rework to benefit from the commit graph. It adds a depth member to RevCommit... maybe a wrapper is better than a subclass?",
      "parentUuid": "c2afec28_a84809e9",
      "revId": "295fa44be20201db29d4d40b7b6cb26ee8d92a3a",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76fe10a2_ae24f741",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/revwalk/RevCommit.java",
        "patchSetId": 41
      },
      "lineNbr": 147,
      "author": {
        "id": 304466
      },
      "writtenOn": "2023-01-04T08:34:53Z",
      "side": 1,
      "message": "\u003e From the caller point of view, why do they need to know about the graph (#parseInGraph())? Callers just indicate \"I will access headers\" with #parseHeaders and where do those headers come from is irrelevant for them. \n\nI agree with this. \nSetting these methods as protect can avoid this problem.\n\n\n\u003e From the caller point of view, why do they need to know about the graph (#parseInGraph())? Callers just indicate \"I will access headers\" with #parseHeaders and where do those headers come from is irrelevant for them. \n\u003e Plus any existing code would benefit from the commit-graph without further change.\n\nBut there is a difference between parseHeaders from commit-graph and pack:\n\nIn order to ensure smaller storage, commit-graph does not record commit\nmessage and other information, so even if RevWalk#isRetainBody() is true, the commit parsed from the commit-graph will not contain the buffer.\n\nAnd this is why I implemented RevCommit#parseHeadersInGraph() instead of parsing the commit-graph directly in the RevCommit#parseHeaders() method.\n\nSome users might use RevWalk#parseHeaders() and then call RevCommit#getFullMessage() to get message, but when they enable commit-graph, they will find that this method may be not work because RevCommit#buffer is null.\n\n\n\u003e The instances are still created/kept by the RevWalk (not in the commit graph), e.g. in RevWalk#createCommit() so all that is the same.\n\u003e Not sure what do you mean in #2. We dont need to subclass RevWalk. DepthWalk.Commit maybe needs some rework to benefit from the commit graph. It adds a depth member to RevCommit... maybe a wrapper is better than a subclass?\n\nI mean:\n\nIn the same RevWalk, the RevCommit instance of the same object is unique.\n\na \u003c- b \n( a is b\u0027s parent )\n\nFor example, we get a RevCommit instance (called a) through RevWalk#parseCommit(), and mark its flag with RevWalk#TEMP_MARK.\n\nThen we get b and parse its header. When we call RevCommit#getParent(0), the obtained instance will be the same as the one mentioned above, and we can still find that its flag is TEMP_MARK.\n\nI wonder if it will be more complicated to use the RevCommitCG subclass because of this.",
      "parentUuid": "795dfdd9_63756126",
      "revId": "295fa44be20201db29d4d40b7b6cb26ee8d92a3a",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    }
  ]
}
{
  "comments": [
    {
      "key": {
        "uuid": "a7c23755_3bab06d6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1628
      },
      "writtenOn": "2017-01-21T01:59:21Z",
      "side": 1,
      "message": "This isn\u0027t precisely true, the time-based eviction will eventually dereference the packfile slices held by the table slots and make them available to the JVM\u0027s GC. This CL proposes to dereference them as soon as the DfsPackFile.close() is called.\n\nThe problem with this approach is that DfsBlockCache.getOrCreate() will return an existing DfsPackFile instance, but it doesn\u0027t reference count them, so evicting the slots on the first call to DfsPackFile.close() strands the other in-flight requests that still hold references to the DfsPackFile (e.g., some of the ObjectInserters hold DfsPackFile references). In a server environment where there can be dozens of inflight requests I\u0027d expect cache hits to go down.",
      "range": {
        "startLine": 11,
        "startChar": 8,
        "endLine": 12,
        "endChar": 6
      },
      "revId": "ca3b9a171e4708cb8685545aea4aac66051031b3",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a7c23755_85ce6c5b",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/dfs/DfsBlockCache.java",
        "patchSetId": 3
      },
      "lineNbr": 411,
      "author": {
        "id": 1
      },
      "writtenOn": "2017-01-25T04:29:43Z",
      "side": 1,
      "message": "Yes, the cache leaks the entry in the hash table, but this is only the HashEntry chain handle and its child Ref node. The actual byte[] was nulled out above by dead.value \u003d null on line 405. So the byte[] can be immediately reclaimed by the Java GC.\n\nI previously didn\u0027t bother to clean the hash table chain during the clock eviction because I assumed we would touch all hash table chains soon enough under other accesses that we would eventually clean these orphaned nodes out of the buckets.",
      "revId": "ca3b9a171e4708cb8685545aea4aac66051031b3",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a7c23755_65287085",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/dfs/DfsBlockCache.java",
        "patchSetId": 3
      },
      "lineNbr": 415,
      "author": {
        "id": 1
      },
      "writtenOn": "2017-01-25T04:29:43Z",
      "side": 1,
      "message": "We can\u0027t take the regionLock while we hold the clockLock. Elsewhere we take regionLock -\u003e clockLock, which will eventually lead to deadlock.",
      "revId": "ca3b9a171e4708cb8685545aea4aac66051031b3",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a7c23755_a5d1a8f9",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/dfs/DfsBlockCache.java",
        "patchSetId": 3
      },
      "lineNbr": 417,
      "author": {
        "id": 1
      },
      "writtenOn": "2017-01-25T04:29:43Z",
      "side": 1,
      "message": "This would fail on the 2nd node in the bucket because entry has advanced and is not pointing at the root of the bucket. You need to use the original value you got for table.get(slot) at the start of the loop, even if you are on the 5th node in the chain.",
      "revId": "ca3b9a171e4708cb8685545aea4aac66051031b3",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a7c23755_e5d720e9",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/dfs/DfsBlockCache.java",
        "patchSetId": 3
      },
      "lineNbr": 527,
      "author": {
        "id": 1
      },
      "writtenOn": "2017-01-25T04:29:43Z",
      "side": 1,
      "message": "Removing all blocks associated with this pack isn\u0027t a bad idea. When the system calls remove(DsfPackFile) we have a pretty good notion the pack file is no longer part of the repository, so the memory its sitting on is now useless.\n\nI just didn\u0027t bother with this \"optimization\", because the cache eviction algorithm should eventually kill those blocks anyway, as they are not being accessed.\n\nIf there is no pressure on the cache to evict (because its at/under target size), then there is no pressure to spend CPU time to evict this dead pack\u0027s blocks. The cache has \"up to\" its target size of memory promised to it, and the rest of the system should be hands off that part of the heap.",
      "range": {
        "startLine": 525,
        "startChar": 0,
        "endLine": 527,
        "endChar": 22
      },
      "revId": "ca3b9a171e4708cb8685545aea4aac66051031b3",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a7c23755_9b9c1abd",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/dfs/DfsObjDatabase.java",
        "patchSetId": 3
      },
      "lineNbr": 302,
      "author": {
        "id": 1628
      },
      "writtenOn": "2017-01-21T01:59:21Z",
      "side": 1,
      "message": "This part of this change is valuable--commitPack is moving the snapshot of current pack files forward, and this change is more quickly evicting stale values from the packCache map. There is a race condition where another thread reads the previous snapshot and then accesses the packCache map with those stale values. DfsPackFile creation is cheap so I think it is a net win.",
      "range": {
        "startLine": 296,
        "startChar": 0,
        "endLine": 302,
        "endChar": 3
      },
      "revId": "ca3b9a171e4708cb8685545aea4aac66051031b3",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
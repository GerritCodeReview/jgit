{
  "comments": [
    {
      "key": {
        "uuid": "70fb2b03_a0c6ae51",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 396,
      "author": {
        "id": 9
      },
      "writtenOn": "2018-06-07T15:14:20Z",
      "side": 1,
      "message": "This hardcodes reading from $HOME/.gitconfig. When running inside\nGerrit this would be the home folder of the user owning Gerrit process.\nThis is not how we usually pass configuration options from Gerrit to\nJGit.\nDo you plan to make this configurable from $GERRIT/etc/gerrit.config, [core] section?",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fc096348_1dcc94ea",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 396,
      "author": {
        "id": 4
      },
      "writtenOn": "2018-06-07T15:43:41Z",
      "side": 1,
      "message": "good catch, I didn\u0027t spot this\n\nI think we should use the repository level configuration like we do for core.trustfolderstat\n\nwe could pass that as another parameter of the createFile method",
      "parentUuid": "70fb2b03_a0c6ae51",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b7cec776_d327084a",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 5
      },
      "writtenOn": "2018-06-06T07:04:11Z",
      "side": 1,
      "message": "Everybody running on POSIX filesystems will now under the hood use this class named NFSFile even if there is no NFS in his environment. Since this class adds quite a few additional filesystem calls (e.g.  config.getBoolean has to check wether repo or global or system config has changed) I would like to give users not using NFS the chance not to use this class. \n\nThis change forces non-NFS users to do instead of  \n\n- File.exists() \n\nthe following\n\n- potentially check 3 config files whether they have changed\n- check the merged configuration whether it contains CONFIG_KEY_REFRESHFOLDERSTAT \n- if not call \"File.exists()\"\n\nA config option like \"EnableNFSSupport\" could do this trick. That could be a config option read once and stored in a static field. Only if that field is true we instantiate NFSFile. Otherwise we simply use the super() implementations of createFile().",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ac7cd1b8_4a8eff4c",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 1684
      },
      "writtenOn": "2018-06-06T08:40:00Z",
      "side": 1,
      "message": "+1. I have the same concerns about performance impact. I do not use NFS, and must not suffer from any performance degradation in such a central place on JGit/Gerrit stack.",
      "parentUuid": "b7cec776_d327084a",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "86f09f90_81fc6c01",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 97483
      },
      "writtenOn": "2018-06-07T13:05:45Z",
      "side": 1,
      "message": "We are using NFS but I am still concerned about using such a global hack for all files accesses.\nWe can\u0027t accept a global performance degradation on all nodes only to fix a single scenario: in-memory cache invalidation.\n\nIs there a way to instead control this from the external? Something like Repository.refreshRefs().\n\nJust to clarify: the data is visible but only the files attributes are cached for files that have been modified. All Git files are immutable, with the exception of refs.\n\nIf we introduce a \"refreshRefs()\" to be called by Gerrit (or whoever uses JGit) only when needed, we won\u0027t have anymore a global performance impact on all the JGit calls and we will still achieve the goal of being able to invalidate the cache.\n\nHow does it sound?\n\nLuca.",
      "parentUuid": "ac7cd1b8_4a8eff4c",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "974a61e2_270b545b",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 4
      },
      "writtenOn": "2018-06-07T13:35:12Z",
      "side": 1,
      "message": "This class is not used for all file access but for access to pack files and for access to refs. \n\nIf the NFS cached view of the pack directory is incomplete we may miss new packfiles in multi-node setup if a new packfile arrived on another node, for refs we may miss new refs, updates or deletes.\n\nAnother issue is visibility of file locks implemented by FileLock between processes running on different nodes.",
      "parentUuid": "86f09f90_81fc6c01",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1ae4efcf_631c6e6d",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 97483
      },
      "writtenOn": "2018-06-07T13:42:24Z",
      "side": 1,
      "message": "\u003e This class is not used for all file access but for access to pack files and for access to refs. \n\nrefs are still read a lot of times ... do we have numbers of the performance degradation?\n\n\u003e If the NFS cached view of the pack directory is incomplete we may miss new packfiles in multi-node setup if a new packfile arrived on another node\n\nYes, saw that and the trustfolderstats flag addresses that, correct? It is then a non-problem anymore.\n\n\u003e for refs we may miss new refs, updates or deletes.\n\nYes, we saw that as well. For packed refs a fix has been merged already. For loose refs the problem is outstanding.\n\n\u003e Another issue is visibility of file locks implemented by FileLock between processes running on different nodes.\n\nIs this addressing FileLock as well?",
      "parentUuid": "974a61e2_270b545b",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b297f19e_bc4c3b61",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 5082
      },
      "writtenOn": "2018-06-07T16:09:38Z",
      "side": 1,
      "message": "\u003e \u003e If the NFS cached view of the pack directory is incomplete we may miss new packfiles in multi-node setup if a new packfile arrived on another node\n\u003e\n\u003e Yes, saw that and the trustfolderstats flag addresses that, correct? It is then a non-problem anymore.\n...\n\u003e Yes, we saw that as well. For packed refs a fix has been merged already. For loose refs the problem is outstanding.\n\nAccording to Hugo, the trustfolderstats solution causes too much of a degradation to be used in practice, they have disabled it.  Instead, they have implemented a hack in Gerrit that basically does something close to what this change does for the specific packed-refs case.  \n\nI can explain the difference between the two solutions.  The current approach of turning off trustfolderstats causes the packedrefs file to be re-read and re-parsed everytime it is accessed.  When the file is large, this is very significant.  The solution proposed in this change is not to reread the packedrefs file everytime, but instead to refresh the directory containing the packedrefs file so as to make the folder stats trustworthy!  In theory, this change now reduces the overhead from reading the entire packedrefs file everytime to a directory open/close.  As far as I can tell, both solutions incur the cost of reading the config file(s) for each packedrefs lookup, so for this specific use case this should not be additional overhead.\n\nAs for the file.exists() use cases, I believe they are generally only in slow paths.  So while these will be significantly longer with this change, I don\u0027t think you should find any degradations in real world use cases that matter.  Of course, real world benchmarking is what really matters, because theory is just theory.  To be specific, here are the uses cases I think are being hit by changes to exists();\n\n1) packfile a) lookup failures, and b) after new file packfile detection\n2) loose object existence lookups (\"has\" object lookups)\n3) loose ref existence during modification lookups\n\nin the case of #1, packfiles, there are some exists() lookups a) after IOExceptions (failure paths), and also b) after detecting new packfiles and reloading them.  The failure \"a\" paths are slow and unusual, it likely does not matter how slow.  As for the \"b\" reloading, this is a not a bulk operation that happens regularly during every git operation, and the overhead is likely minimal compared to actually loading the new pack index.\n\nIn the case of #2, loose objects, generally these are looked up in a cache first, if that fails, then the packed objects are looked up, and if that fails, then the loose object is looked up.  This last lookup is not a failure path, but it is generally the slow path.  That is the case the would concern me the most.  I believe that once the loose object is looked up once, it will make it into the cache though, so it should be faster thereafter.  If this case is too slow in the real world, this could potentially be improved by only refreshing when exists() returns a false.  I suspect that this doesn\u0027t matter in the real world, on Gerrit servers there are generally very few loose objects that are not in packfiles, and this is when it would hit.\n\nLastly in the case of #3, I don\u0027t think this is a common jgit case, at least not in any bulk operations.  Most accesses to refs are ref-advertisements that will not use exists().  Generally the exists() is only used when modifying the ref, and that tends to be a slow path already.\n\nI hope this clarifies most things, I may have missed some cases?",
      "parentUuid": "1ae4efcf_631c6e6d",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
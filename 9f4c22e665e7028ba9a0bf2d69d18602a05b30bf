{
  "comments": [
    {
      "key": {
        "uuid": "70fb2b03_a0c6ae51",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 396,
      "author": {
        "id": 9
      },
      "writtenOn": "2018-06-07T15:14:20Z",
      "side": 1,
      "message": "This hardcodes reading from $HOME/.gitconfig. When running inside\nGerrit this would be the home folder of the user owning Gerrit process.\nThis is not how we usually pass configuration options from Gerrit to\nJGit.\nDo you plan to make this configurable from $GERRIT/etc/gerrit.config, [core] section?",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fc096348_1dcc94ea",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 396,
      "author": {
        "id": 4
      },
      "writtenOn": "2018-06-07T15:43:41Z",
      "side": 1,
      "message": "good catch, I didn\u0027t spot this\n\nI think we should use the repository level configuration like we do for core.trustfolderstat\n\nwe could pass that as another parameter of the createFile method",
      "parentUuid": "70fb2b03_a0c6ae51",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b7cec776_d327084a",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 5
      },
      "writtenOn": "2018-06-06T07:04:11Z",
      "side": 1,
      "message": "Everybody running on POSIX filesystems will now under the hood use this class named NFSFile even if there is no NFS in his environment. Since this class adds quite a few additional filesystem calls (e.g.  config.getBoolean has to check wether repo or global or system config has changed) I would like to give users not using NFS the chance not to use this class. \n\nThis change forces non-NFS users to do instead of  \n\n- File.exists() \n\nthe following\n\n- potentially check 3 config files whether they have changed\n- check the merged configuration whether it contains CONFIG_KEY_REFRESHFOLDERSTAT \n- if not call \"File.exists()\"\n\nA config option like \"EnableNFSSupport\" could do this trick. That could be a config option read once and stored in a static field. Only if that field is true we instantiate NFSFile. Otherwise we simply use the super() implementations of createFile().",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ac7cd1b8_4a8eff4c",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 1684
      },
      "writtenOn": "2018-06-06T08:40:00Z",
      "side": 1,
      "message": "+1. I have the same concerns about performance impact. I do not use NFS, and must not suffer from any performance degradation in such a central place on JGit/Gerrit stack.",
      "parentUuid": "b7cec776_d327084a",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "86f09f90_81fc6c01",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 97483
      },
      "writtenOn": "2018-06-07T13:05:45Z",
      "side": 1,
      "message": "We are using NFS but I am still concerned about using such a global hack for all files accesses.\nWe can\u0027t accept a global performance degradation on all nodes only to fix a single scenario: in-memory cache invalidation.\n\nIs there a way to instead control this from the external? Something like Repository.refreshRefs().\n\nJust to clarify: the data is visible but only the files attributes are cached for files that have been modified. All Git files are immutable, with the exception of refs.\n\nIf we introduce a \"refreshRefs()\" to be called by Gerrit (or whoever uses JGit) only when needed, we won\u0027t have anymore a global performance impact on all the JGit calls and we will still achieve the goal of being able to invalidate the cache.\n\nHow does it sound?\n\nLuca.",
      "parentUuid": "ac7cd1b8_4a8eff4c",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "974a61e2_270b545b",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 4
      },
      "writtenOn": "2018-06-07T13:35:12Z",
      "side": 1,
      "message": "This class is not used for all file access but for access to pack files and for access to refs. \n\nIf the NFS cached view of the pack directory is incomplete we may miss new packfiles in multi-node setup if a new packfile arrived on another node, for refs we may miss new refs, updates or deletes.\n\nAnother issue is visibility of file locks implemented by FileLock between processes running on different nodes.",
      "parentUuid": "86f09f90_81fc6c01",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1ae4efcf_631c6e6d",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 97483
      },
      "writtenOn": "2018-06-07T13:42:24Z",
      "side": 1,
      "message": "\u003e This class is not used for all file access but for access to pack files and for access to refs. \n\nrefs are still read a lot of times ... do we have numbers of the performance degradation?\n\n\u003e If the NFS cached view of the pack directory is incomplete we may miss new packfiles in multi-node setup if a new packfile arrived on another node\n\nYes, saw that and the trustfolderstats flag addresses that, correct? It is then a non-problem anymore.\n\n\u003e for refs we may miss new refs, updates or deletes.\n\nYes, we saw that as well. For packed refs a fix has been merged already. For loose refs the problem is outstanding.\n\n\u003e Another issue is visibility of file locks implemented by FileLock between processes running on different nodes.\n\nIs this addressing FileLock as well?",
      "parentUuid": "974a61e2_270b545b",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b297f19e_bc4c3b61",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 5082
      },
      "writtenOn": "2018-06-07T16:09:38Z",
      "side": 1,
      "message": "\u003e \u003e If the NFS cached view of the pack directory is incomplete we may miss new packfiles in multi-node setup if a new packfile arrived on another node\n\u003e\n\u003e Yes, saw that and the trustfolderstats flag addresses that, correct? It is then a non-problem anymore.\n...\n\u003e Yes, we saw that as well. For packed refs a fix has been merged already. For loose refs the problem is outstanding.\n\nAccording to Hugo, the trustfolderstats solution causes too much of a degradation to be used in practice, they have disabled it.  Instead, they have implemented a hack in Gerrit that basically does something close to what this change does for the specific packed-refs case.  \n\nI can explain the difference between the two solutions.  The current approach of turning off trustfolderstats causes the packedrefs file to be re-read and re-parsed everytime it is accessed.  When the file is large, this is very significant.  The solution proposed in this change is not to reread the packedrefs file everytime, but instead to refresh the directory containing the packedrefs file so as to make the folder stats trustworthy!  In theory, this change now reduces the overhead from reading the entire packedrefs file everytime to a directory open/close.  As far as I can tell, both solutions incur the cost of reading the config file(s) for each packedrefs lookup, so for this specific use case this should not be additional overhead.\n\nAs for the file.exists() use cases, I believe they are generally only in slow paths.  So while these will be significantly longer with this change, I don\u0027t think you should find any degradations in real world use cases that matter.  Of course, real world benchmarking is what really matters, because theory is just theory.  To be specific, here are the uses cases I think are being hit by changes to exists();\n\n1) packfile a) lookup failures, and b) after new file packfile detection\n2) loose object existence lookups (\"has\" object lookups)\n3) loose ref existence during modification lookups\n\nin the case of #1, packfiles, there are some exists() lookups a) after IOExceptions (failure paths), and also b) after detecting new packfiles and reloading them.  The failure \"a\" paths are slow and unusual, it likely does not matter how slow.  As for the \"b\" reloading, this is a not a bulk operation that happens regularly during every git operation, and the overhead is likely minimal compared to actually loading the new pack index.\n\nIn the case of #2, loose objects, generally these are looked up in a cache first, if that fails, then the packed objects are looked up, and if that fails, then the loose object is looked up.  This last lookup is not a failure path, but it is generally the slow path.  That is the case the would concern me the most.  I believe that once the loose object is looked up once, it will make it into the cache though, so it should be faster thereafter.  If this case is too slow in the real world, this could potentially be improved by only refreshing when exists() returns a false.  I suspect that this doesn\u0027t matter in the real world, on Gerrit servers there are generally very few loose objects that are not in packfiles, and this is when it would hit.\n\nLastly in the case of #3, I don\u0027t think this is a common jgit case, at least not in any bulk operations.  Most accesses to refs are ref-advertisements that will not use exists().  Generally the exists() is only used when modifying the ref, and that tends to be a slow path already.\n\nI hope this clarifies most things, I may have missed some cases?",
      "parentUuid": "1ae4efcf_631c6e6d",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8dc06b5c_c22a3c78",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 97483
      },
      "writtenOn": "2018-06-07T16:42:38Z",
      "side": 1,
      "message": "\u003e \u003e \u003e If the NFS cached view of the pack directory is incomplete we may miss new packfiles in multi-node setup if a new packfile arrived on another node\n\u003e \u003e\n\u003e \u003e Yes, saw that and the trustfolderstats flag addresses that, correct? It is then a non-problem anymore.\n\u003e ...\n\u003e \u003e Yes, we saw that as well. For packed refs a fix has been merged already. For loose refs the problem is outstanding.\n\u003e \n\u003e According to Hugo, the trustfolderstats solution causes too much of a degradation to be used in practice, they have disabled it.  Instead, they have implemented a hack in Gerrit that basically does something close to what this change does for the specific packed-refs case.  \n\u003e \n\u003e I can explain the difference between the two solutions.  The current approach of turning off trustfolderstats causes the packedrefs file to be re-read and re-parsed everytime it is accessed.  When the file is large, this is very significant.  The solution proposed in this change is not to reread the packedrefs file everytime, but instead to refresh the directory containing the packedrefs file so as to make the folder stats trustworthy!  In theory, this change now reduces the overhead from reading the entire packedrefs file everytime to a directory open/close.  As far as I can tell, both solutions incur the cost of reading the config file(s) for each packedrefs lookup, so for this specific use case this should not be additional overhead.\n\nShould then the revert of  I2b65cfa a predecessor of this change?\nIf we refresh folder stats, we always trust them afterwards.\n\n\u003e As for the file.exists() use cases, I believe they are generally only in slow paths.  So while these will be significantly longer with this change, I don\u0027t think you should find any degradations in real world use cases that matter.  Of course, real world benchmarking is what really matters, because theory is just theory.  To be specific, here are the uses cases I think are being hit by changes to exists();\n\nYes, cannot test *this* patch specifically: I am on Gerrit 2.15.2 which is based on JGit 4.9.2.\nHowever, I applied the same hack to a local stable-4.9 and I am testing it on GerritHub.io. Will come back with results on a real heavily loaded production system. Maybe not as much as Hugo\u0027s, but close ;-)\n\n\u003e 1) packfile a) lookup failures, and b) after new file packfile detection\n\u003e 2) loose object existence lookups (\"has\" object lookups)\n\u003e 3) loose ref existence during modification lookups\n\n4) loose ref snapshot conditional refresh as well. This is specifically our case. A ref gets updated but the other nodes do not flush the in-memory cache in real time. It takes a few seconds to realise the new value and invalidate the in-memory cache.\n\n\u003e in the case of #1, packfiles, there are some exists() lookups a) after IOExceptions (failure paths), and also b) after detecting new packfiles and reloading them.  The failure \"a\" paths are slow and unusual, it likely does not matter how slow.  As for the \"b\" reloading, this is a not a bulk operation that happens regularly during every git operation, and the overhead is likely minimal compared to actually loading the new pack index.\n\u003e \n\u003e In the case of #2, loose objects, generally these are looked up in a cache first, if that fails, then the packed objects are looked up, and if that fails, then the loose object is looked up.  This last lookup is not a failure path, but it is generally the slow path.  That is the case the would concern me the most.  I believe that once the loose object is looked up once, it will make it into the cache though, so it should be faster thereafter.  If this case is too slow in the real world, this could potentially be improved by only refreshing when exists() returns a false.  I suspect that this doesn\u0027t matter in the real world, on Gerrit servers there are generally very few loose objects that are not in packfiles, and this is when it would hit.\n\u003e \n\u003e Lastly in the case of #3, I don\u0027t think this is a common jgit case, at least not in any bulk operations.  Most accesses to refs are ref-advertisements that will not use exists().  Generally the exists() is only used when modifying the ref, and that tends to be a slow path already.\n\ncase of #4 is done every time that someone does a ref lookup: running on our production (failover node) and will try to redirect a bit of load and will come back with some numbers.\n\nThe Gerrit startup phase and project cache warm-up is a lot slower though: it generates millions of calls to the hack :-(\n\n\u003e \n\u003e I hope this clarifies most things, I may have missed some cases?\n\nYes, it does. Thanks.\n\nSee the 4) I mentioned, it is exactly our interest in this patch.",
      "parentUuid": "b297f19e_bc4c3b61",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ecafee61_9a2f293f",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 97483
      },
      "writtenOn": "2018-06-07T17:13:49Z",
      "side": 1,
      "message": "It has been live for 10 mins \u003d\u003e 1.7M calls\nI have to say that we have 15k active users and over 40k repositories.\n\nThe project cache warm-up consumed 1M of those calls. Let\u0027s say then that the average number of calls per minute was 70k /minute.\n\nSee below my ioping stats:\n4 KiB \u003c\u003c\u003c /var/gerrit/git (nfs4 10.0.20.2:/var/gerrit/git): request\u003d2 time\u003d499.9 us\n\nWhilst on the local FS the ioping stats are:\n4 KiB \u003c\u003c\u003c /var/gerrit (ext4 /dev/root): request\u003d3 time\u003d258.2 us\n\nEven though the number of calls is significant (1100 TPS of calls to the refresh stats) the end user performance are still good. I suspect that I am generating however quite a bit of network I/O. Will leave it running on the failover node for 2-3h and give the final results as feedback to this change.",
      "parentUuid": "8dc06b5c_c22a3c78",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7d8b4df0_afc17fb1",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 5082
      },
      "writtenOn": "2018-06-07T17:42:45Z",
      "side": 1,
      "message": "Yes, I think you are right about #4, I didn\u0027t realize those were even being cached!  For #4 the lastModified() is being used.  A difficult, but potential improvement could be to only refresh the dir once per ref directory, but I don\u0027t think the code layout would make that very doable.  I would be concerned about this use case if it is a \"bulk\" operation that is used during ref advertisement?",
      "parentUuid": "ecafee61_9a2f293f",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a1b6e223_44704782",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 97483
      },
      "writtenOn": "2018-06-07T20:46:30Z",
      "side": 1,
      "message": "\u003e Yes, I think you are right about #4, I didn\u0027t realize those were even being cached!  For #4 the lastModified() is being used.  A difficult, but potential improvement could be to only refresh the dir once per ref directory,\n\nExactly, and I wanted to expose it upstream as an API to be used by Gerrit.\nGerrit *knows* when the ref directory needs to be checked with a refreshed set of access data:\n- When a index sync is received\n- When a replication needs to be triggered\n- Before and after a GC cycle\n\nBy having the tool available (Repository.refreshRefs()) upstream, we could get all the benefits without any overload in terms of CPU or I/O to the NFS share.\n\n\u003e but I don\u0027t think the code layout would make that very doable. \n\nLet me try a patch on top of stable-4.9 (the one used in Gerrit 2.15)\n\n\u003e I would be concerned about this use case if it is a \"bulk\" operation that is used during ref advertisement?\n\nSee below the stats of 2h of production load with this hack:\n- 7.3M calls to refresh stats over 9.5k repositories, an average of 768 calls per repo\n- The most active repo (spdk/spdk - 30k refs) had 3.4M calls\n\nBear in mind that if we expose the API upstream, we DO NOT need to call it all the times for all operations.\n\nExample:\nIt is absolutely acceptable that a regular from a failover node gets a not 100% up-to-date ref value. However, when you push, you always want to make sure to have the latest version.\n\nThat would allow to massively reduce the number of calls to the API.",
      "parentUuid": "7d8b4df0_afc17fb1",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "384b0c6a_5fe4efba",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 4
      },
      "lineNbr": 410,
      "author": {
        "id": 97483
      },
      "writtenOn": "2018-06-07T21:07:14Z",
      "side": 1,
      "message": "More stats about %CPU usage and system load:\n- Avg Baseline: CPU \u003d 2%, System Load \u003d 1.3\n- Avg w/ refresh stats: CPU \u003d 30%, System Load \u003d 3\n\nBecause we have plenty of over-capacity on GerritHub.io on both NFS bandwidth, CPU and cores, the additional load did not generate any significant delay anywhere.\n\nHowever, if you are applying this patch to a more overloaded server that is running at 50% of the available capacity, the performance penalties would be noticeable.",
      "parentUuid": "a1b6e223_44704782",
      "revId": "9f4c22e665e7028ba9a0bf2d69d18602a05b30bf",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
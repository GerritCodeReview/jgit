{
  "comments": [
    {
      "key": {
        "uuid": "AABOJ3//+l4\u003d",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/merge/RecursiveMerger.java",
        "patchSetId": 12
      },
      "lineNbr": 392,
      "author": {
        "id": 5
      },
      "writtenOn": "2012-12-05T22:03:17Z",
      "side": 1,
      "message": "This loop is strange. Where is the final result stored? It can\u0027t be in resultTree. Somehow I thought that you run through this loop and in every iteration you merge one new commonAncestor into what you have constructed so far. And what you have constructed so far is stored in resultTree. But no: you always merge a new commonAncestor with the never-changing firstCommonAncestor.\nMy statement is: it doesn\u0027t matter how many commonAncestors you have and how they look like: in the end resultTree will always contain only the result of a merge between the first and the last common ancestor. The intermediate commonAncestors are ignored. That can\u0027t be ok.",
      "revId": "a43d856db3d2e25b955d7846ba379bca81e0e3be",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOJ3//+mU\u003d",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/merge/RecursiveMerger.java",
        "patchSetId": 12
      },
      "lineNbr": 415,
      "author": {
        "id": 5
      },
      "writtenOn": "2012-12-05T22:03:17Z",
      "side": 1,
      "message": "Here comes one problem: Imagine you are running in the Gerrit environment on a bare repo without an index. When you construct the RecursiveMerge instance a new, empty incore index is instantiated and stored in this.dircache. When you reach line 395 this index is filled and it finally contains the state of the newly calculated mergeBase. Now you reach this line 415 and you start a mergeTrees(). mergeTrees will not only look at the given trees but also take the index into account. And the git merge algorithms assume that the index is based on the first tree. (Analogy: on git command line you assume that your index is based on HEAD which is always the first tree). Whenever first tree and index differ the merge assume we have an \"dirty index\" and stop. That is the reason why the test lowLevelBareRepo_CrissCrossMerge() fails!\n\nWe have to make sure that when we reach this point we have an index set to the h1 content. The index which was filled during calculation of the merge base can be dumped.",
      "revId": "a43d856db3d2e25b955d7846ba379bca81e0e3be",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
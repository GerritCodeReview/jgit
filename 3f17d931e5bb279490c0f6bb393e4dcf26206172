{
  "comments": [
    {
      "key": {
        "uuid": "0724e3f1_3d626780",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriterBitmapPreparer.java",
        "patchSetId": 1
      },
      "lineNbr": 268,
      "author": {
        "id": 951
      },
      "writtenOn": "2015-10-28T19:59:09Z",
      "side": 1,
      "message": "I\u0027m having trouble understanding this. Why does sorting lead to better compression?\n\nc is a commit we want to build a bitmap for.\n\nfullBitmap lists its ancestors that are not ancestors of one of the reusedCommits.\n\nmergedBranches is a collection of lists of bitmaps. We want to add c to one of them.\n\nmatchedBranches is created by filtering mergedBranches to ancestors of c.\n\nWe are going to add c to the longest one of those. The reuseWalker flag indicates whether it\u0027s at the beginning of the list.\n\nThen they\u0027ll be concatenated to produce the part of the output of selectCommits corresponding to entry.\n\nSo the resulting list of BitmapCommits looks like this:\n\n (reused commits)\n C, reuseWalker \u003d\u003d false, FLAG_REUSE\n\n (for each want)\n C1, reuseWalker \u003d\u003d false, (FLAG_REUSE if and only if distant)\n C2, reuseWalker \u003d\u003d true, ...\n ...\n D1, reuseWalker \u003d\u003d false, ...\n D2, reuseWalker \u003d\u003d true, ...\n ...\n\n (for each want that wasn\u0027t selected in the above loop)\n C, reuseWalker \u003d\u003d false, 0\n\nWhen reuseWalker is true, the PackWriterBitmapWalker can start from the previous bitmap because the previous commit is an ancestor of the next one. So at first glance this seems to be about efficiency of generating bitmaps instead of being about compression.",
      "range": {
        "startLine": 266,
        "startChar": 0,
        "endLine": 268,
        "endChar": 15
      },
      "revId": "3f17d931e5bb279490c0f6bb393e4dcf26206172",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
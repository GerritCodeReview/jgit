{
  "comments": [
    {
      "key": {
        "uuid": "b627e6c4_cb2bae4e",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/GC.java",
        "patchSetId": 1
      },
      "lineNbr": 888,
      "author": {
        "id": 44628
      },
      "writtenOn": "2018-07-08T14:04:37Z",
      "side": 1,
      "message": "Maybe I\u0027m missing something obvious as I\u0027m not familiar with this code. But I don\u0027t understand all this code (both Hector\u0027s original version and this changed version).\n\nFirst, isn\u0027t there still a race condition between asynchronous GC removing a directory and some other thread (or even external git) concurrently trying to create a new loose ref? What if the directory deletion here happens _between_ the mkdirs() and the createNewFile() in LockFile.lock()? Then creating the new ref would fail because GC just removed the directory that LockFile thought it had just ensured that it existed. (Since the directory exists already, the mkdirs() would not even have changed the timestamp...)\n\nSecond, if I\u0027m reading the code of RefDirectory.pack() correctly, empty ref directories should be removed there already?",
      "revId": "8d02c73643b9d2213a1f24ee9c997b4f9b7b7fd8",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f8ab4d5_d436d238",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/GC.java",
        "patchSetId": 1
      },
      "lineNbr": 888,
      "author": {
        "id": 97483
      },
      "writtenOn": "2018-07-08T21:04:47Z",
      "side": 1,
      "message": "\u003e Maybe I\u0027m missing something obvious as I\u0027m not familiar with this code. But I don\u0027t understand all this code (both Hector\u0027s original version and this changed version).\n\nMy code is simply the fix of Hector\u0027s code.\n\n\u003e First, isn\u0027t there still a race condition between asynchronous GC removing a directory and some other thread (or even external git) concurrently trying to create a new loose ref? What if the directory deletion here happens _between_ the mkdirs() and the createNewFile() in LockFile.lock()? Then creating the new ref would fail because GC just removed the directory that LockFile thought it had just ensured that it existed. (Since the directory exists already, the mkdirs() would not even have changed the timestamp...)\n\nYes, that may happen. The client will get an error and hopefully the person that tried the push will try again.\n\n\u003e Second, if I\u0027m reading the code of RefDirectory.pack() correctly, empty ref directories should be removed there already?\n\nThat is what I thought, but wasn\u0027t working.\nI was about to try to fix that code when it was pointed out that Hector fixed it already. That\u0027s why I concentrated my efforts in using Hector\u0027s approach.",
      "parentUuid": "b627e6c4_cb2bae4e",
      "revId": "8d02c73643b9d2213a1f24ee9c997b4f9b7b7fd8",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f396a1bb_06692ae2",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/GC.java",
        "patchSetId": 1
      },
      "lineNbr": 888,
      "author": {
        "id": 44628
      },
      "writtenOn": "2018-07-08T21:29:07Z",
      "side": 1,
      "message": "\u003e Yes, that may happen. The client will get an error and hopefully\n \u003e the person that tried the push will try again.\n\nNot only push. This can also happen in the client (for instance in EGit in Eclipse), if GC runs concurrently (as it does by default). Creating a branch or tag might fail, giving the user an error he\u0027d not understand.\n\n \u003e \u003e Second, if I\u0027m reading the code of RefDirectory.pack() correctly,\n \u003e empty ref directories should be removed there already?\n \u003e \n \u003e That is what I thought, but wasn\u0027t working.\n \u003e I was about to try to fix that code when it was pointed out that\n \u003e Hector fixed it already. That\u0027s why I concentrated my efforts in\n \u003e using Hector\u0027s approach.\n\nBut now that I\u0027ve looked at Hector\u0027s approach and your modification of it in detail I have the impression that this whole approach is in the wrong place and it would indeed be better to figure out why the deletion in RefDirectory.pack() doesn\u0027t work, and then fix it there, and remove this attempt here altogether. (Though RefDirectory will do it only for freshly packed refs, so if there are a lot of old empty folders, some additional cleanup would be needed anyway... and RefDirectory has a similar race condition...)\n\nWhat does the C implementation of git do? I suppose they would have the same issues. How is this solved there?",
      "parentUuid": "9f8ab4d5_d436d238",
      "revId": "8d02c73643b9d2213a1f24ee9c997b4f9b7b7fd8",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0587e679_3c9c934b",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/GC.java",
        "patchSetId": 1
      },
      "lineNbr": 888,
      "author": {
        "id": 97483
      },
      "writtenOn": "2018-07-08T21:43:16Z",
      "side": 1,
      "message": "\u003e \u003e Yes, that may happen. The client will get an error and hopefully\n\u003e  \u003e the person that tried the push will try again.\n\u003e \n\u003e Not only push. This can also happen in the client (for instance in EGit in Eclipse), if GC runs concurrently (as it does by default). Creating a branch or tag might fail, giving the user an error he\u0027d not understand.\n\u003e \n\u003e  \u003e \u003e Second, if I\u0027m reading the code of RefDirectory.pack() correctly,\n\u003e  \u003e empty ref directories should be removed there already?\n\u003e  \u003e \n\u003e  \u003e That is what I thought, but wasn\u0027t working.\n\u003e  \u003e I was about to try to fix that code when it was pointed out that\n\u003e  \u003e Hector fixed it already. That\u0027s why I concentrated my efforts in\n\u003e  \u003e using Hector\u0027s approach.\n\u003e \n\u003e But now that I\u0027ve looked at Hector\u0027s approach and your modification of it in detail I have the impression that this whole approach is in the wrong place and it would indeed be better to figure out why the deletion in RefDirectory.pack() doesn\u0027t work, and then fix it there, and remove this attempt here altogether. \n\nHector\u0027s fix doesn\u0027t work anyway :-(\nIt would be helpful to ask Hector if the fix actually works or not for them in production.\n\n\u003e (Though RefDirectory will do it only for freshly packed refs, so if there are a lot of old empty folders, some additional cleanup would be needed anyway... and RefDirectory has a similar race condition...)\n\u003e \n\u003e What does the C implementation of git do? I suppose they would have the same issues. How is this solved there?\n\nHonestly I believe CGit doesn\u0027t do a good job anyway: I tried a gc pack-refs and many obsolete empty dirs were not removed.",
      "parentUuid": "f396a1bb_06692ae2",
      "revId": "8d02c73643b9d2213a1f24ee9c997b4f9b7b7fd8",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f768a975_b30e7931",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/GC.java",
        "patchSetId": 1
      },
      "lineNbr": 888,
      "author": {
        "id": 44628
      },
      "writtenOn": "2018-07-08T22:55:53Z",
      "side": 1,
      "message": "\u003e Honestly I believe CGit doesn\u0027t do a good job anyway: I tried a gc\n \u003e pack-refs and many obsolete empty dirs were not removed.\n\nInteresting. Looking at the code in C git ([1] called via [2]) they seem to do basically the same as we do in RefDirectory.pack(). So why would that leave empty directories behind?\n\n[1] https://github.com/git/git/blob/50f08db/refs/files-backend.c#L986\n[2] https://github.com/git/git/blob/50f08db/refs/files-backend.c#L2816",
      "parentUuid": "0587e679_3c9c934b",
      "revId": "8d02c73643b9d2213a1f24ee9c997b4f9b7b7fd8",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "862bb052_d1a6e557",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/GC.java",
        "patchSetId": 1
      },
      "lineNbr": 888,
      "author": {
        "id": 24046
      },
      "writtenOn": "2018-07-09T12:16:03Z",
      "side": 1,
      "message": "We\u0027ve been using this code in production since some months ago and the performance issue associated with lots of empty refs folders is gone. I can also confirm that cgit gc leaves behind those empty folders, at least it did last time I tried it (git 2.15)",
      "parentUuid": "f768a975_b30e7931",
      "revId": "8d02c73643b9d2213a1f24ee9c997b4f9b7b7fd8",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb54c51f_682a2d8e",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/GC.java",
        "patchSetId": 1
      },
      "lineNbr": 888,
      "author": {
        "id": 97483
      },
      "writtenOn": "2018-07-09T14:10:24Z",
      "side": 1,
      "message": "Using the fix as-is, I saw that only the 1st level of directories was removed but not the others.\nExample:\n\nBefore:\nrefs/changes/45/271629/20\n\nAfter:\nrefs/changes/45/271629\n\nBottom line: the number of directories to navigate was still huge.\n\nThe problem was in the sequence of the filtering + removal: after removing the \u0027/20\u0027 from the example above, the parent directly had its lastUpdateTs updated and thus wasn\u0027t removed.",
      "parentUuid": "862bb052_d1a6e557",
      "revId": "8d02c73643b9d2213a1f24ee9c997b4f9b7b7fd8",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "668245af_a0ba6200",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/GC.java",
        "patchSetId": 1
      },
      "lineNbr": 888,
      "author": {
        "id": 97483
      },
      "writtenOn": "2018-07-09T14:20:17Z",
      "side": 1,
      "message": "Real-life example with numbers for a repo with 500k changes, and an average of 3 PS per change.\n\nBefore the prune: 500k * 2 *  (3 + 1) \u003d 4M of directories\nAfter the  prune: 500k * 2 \u003d 1M of directories\n\nYes, there is a reduction, but still, it will take a while to navigate 1M of directories, to find out eventually that none of them has any loose refs.\n\nWith the extra follow-up fix that I pushed, after the prune, only the refs/{changes,heads,tags,meta} were still present, and all the other empty sub-directories were removed.\n\nWe have noticed a significant improvement in performance for Git clones and pushes. (2 to 3 times faster)",
      "parentUuid": "eb54c51f_682a2d8e",
      "revId": "8d02c73643b9d2213a1f24ee9c997b4f9b7b7fd8",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
{
  "comments": [
    {
      "key": {
        "uuid": "804fa068_82e70553",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/transport/RefSpec.java",
        "patchSetId": 9
      },
      "lineNbr": 418,
      "author": {
        "id": 951
      },
      "writtenOn": "2019-03-05T01:08:50Z",
      "side": 1,
      "message": "fetches (pull \u003d fetch + merge)",
      "range": {
        "startLine": 418,
        "startChar": 48,
        "endLine": 418,
        "endChar": 53
      },
      "revId": "48e22905286af76c904d9109fa05478a2ba21a52",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "55ee5542_cd46d1e2",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/transport/RefSpec.java",
        "patchSetId": 9
      },
      "lineNbr": 418,
      "author": {
        "id": 224620
      },
      "writtenOn": "2019-03-06T00:51:47Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "804fa068_82e70553",
      "range": {
        "startLine": 418,
        "startChar": 48,
        "endLine": 418,
        "endChar": 53
      },
      "revId": "48e22905286af76c904d9109fa05478a2ba21a52",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cadc5b66_90ff7bca",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/transport/RefSpec.java",
        "patchSetId": 9
      },
      "lineNbr": 420,
      "author": {
        "id": 951
      },
      "writtenOn": "2019-03-05T01:08:50Z",
      "side": 1,
      "message": "I suspect \"contains\" semantics are not what we\u0027d want for this: what if the destination patterns *overlap* without one being a superset of the other?",
      "range": {
        "startLine": 419,
        "startChar": 4,
        "endLine": 420,
        "endChar": 25
      },
      "revId": "48e22905286af76c904d9109fa05478a2ba21a52",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f03477e9_20678380",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/transport/RefSpec.java",
        "patchSetId": 9
      },
      "lineNbr": 420,
      "author": {
        "id": 224620
      },
      "writtenOn": "2019-03-05T02:16:20Z",
      "side": 1,
      "message": "I had concluded that was impossible, but I wasn\u0027t considering the case where 1 pattern has parts both before and after *, while the other pattern has only parts before or only after.\n\nA \u003d a/b/*/y/z   matches a/b/c/x/y/z and a/b/d/y/z\nB \u003d a/b/c/*      matches a/b/c/x/y/z and a/b/c/d\nC \u003d */x/y/z       matches a/b/c/x/y/z and w/x/y/z\n\nCan you think of another case that has partial intersection? I think I can recognize this case by observing that A and B share a prefix, B has a longer prefix before the *, and B has no suffix (similar for A and C). This will also identify that B and C overlap.\n\nAs long as I\u0027m confident that this is every case, I will go ahead and rename the method destinationIntersects and add this logic.",
      "parentUuid": "cadc5b66_90ff7bca",
      "range": {
        "startLine": 419,
        "startChar": 4,
        "endLine": 420,
        "endChar": 25
      },
      "revId": "48e22905286af76c904d9109fa05478a2ba21a52",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "214b2ae0_33ffa78e",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/transport/RefSpec.java",
        "patchSetId": 9
      },
      "lineNbr": 420,
      "author": {
        "id": 951
      },
      "writtenOn": "2019-03-05T02:26:26Z",
      "side": 1,
      "message": "\u003e As long as I\u0027m confident that this is every case, I will go ahead and rename the method destinationIntersects and add this logic.\n\nYay!\n\nOne possible rule would be:\n* if A or B has no wildcard, match it against the other one\n* otherwise, check whether \"A\u0027s prefix is a prefix of B\u0027s prefix, or vice versa, and A\u0027s suffix is a suffix of B\u0027s suffix, or vice versa\".\n\nFor example:\n\n  refs/heads/a*z, refs/heads/ab*yz: overlaps since A\u0027s prefix and suffix are a prefix and suffix of B\u0027s, respectively\n  refs/heads/abz, refs/heads/a*z: overlaps since A matches B\n  refs/heads/aba, refs/heads/ab*ba: does not overlap since A does not match B\n  refs/heads/ab*a, refs/heads/a*za: overlaps since B\u0027s prefix is a prefix of A\u0027s and A\u0027s suffix is a suffix of B\u0027s",
      "parentUuid": "f03477e9_20678380",
      "range": {
        "startLine": 419,
        "startChar": 4,
        "endLine": 420,
        "endChar": 25
      },
      "revId": "48e22905286af76c904d9109fa05478a2ba21a52",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d9f69f0a_c4f24dbd",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/transport/RefSpec.java",
        "patchSetId": 9
      },
      "lineNbr": 420,
      "author": {
        "id": 224620
      },
      "writtenOn": "2019-03-06T00:51:47Z",
      "side": 1,
      "message": "Refspec doesn\u0027t allow wildcards in the middle of words, so we don\u0027t need to worry about  the examples you provide.\n\nI decided to strip the shared prefix/suffix from both patterns. Then I check that one of the stripped patterns has the wildcard as the prefix. If so, then that wildcard will match the prefix of the other pattern no matter what it is. I make the same check for the suffix. There\u0027s also an equals check for the non-wildcard case.",
      "parentUuid": "214b2ae0_33ffa78e",
      "range": {
        "startLine": 419,
        "startChar": 4,
        "endLine": 420,
        "endChar": 25
      },
      "revId": "48e22905286af76c904d9109fa05478a2ba21a52",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "538bd39f_9c8f93f3",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/transport/RefSpec.java",
        "patchSetId": 9
      },
      "lineNbr": 420,
      "author": {
        "id": 951
      },
      "writtenOn": "2019-03-06T00:54:09Z",
      "side": 1,
      "message": "If you put slashes around the *, the same examples should still work:\n\n refs/heads/a/*/z, refs/heads/a/b/*/y/z: overlaps\n refs/heads/a/b/z, refs/heads/a/*/z: overlaps\n refs/heads/a/b/a, refs/heads/a/b/*/b/a: no overlap\n refs/heads/a/b/*/a, refs/heads/a/*/z/a: overlaps",
      "parentUuid": "d9f69f0a_c4f24dbd",
      "range": {
        "startLine": 419,
        "startChar": 4,
        "endLine": 420,
        "endChar": 25
      },
      "revId": "48e22905286af76c904d9109fa05478a2ba21a52",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2653a64f_61a99138",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/transport/RefSpec.java",
        "patchSetId": 9
      },
      "lineNbr": 420,
      "author": {
        "id": 224620
      },
      "writtenOn": "2019-03-06T23:50:47Z",
      "side": 1,
      "message": "I believe the new test cases cover the same scenarios as you\u0027re suggesting.",
      "parentUuid": "538bd39f_9c8f93f3",
      "range": {
        "startLine": 419,
        "startChar": 4,
        "endLine": 420,
        "endChar": 25
      },
      "revId": "48e22905286af76c904d9109fa05478a2ba21a52",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    }
  ]
}
{
  "comments": [
    {
      "key": {
        "uuid": "AABOPX//9fo\u003d",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/revwalk/DateRevQueue.java",
        "patchSetId": 7
      },
      "lineNbr": 87,
      "author": {
        "id": 1
      },
      "writtenOn": "2013-02-22T17:49:38Z",
      "side": 1,
      "message": "I think you can rewrite this:\n\n  if (++sinceLastIndex \u003e REBUILD_INDEX_COUNT)\n    buildIndex();\n  inQueue++;\n\nand move the sinceLastIndex reset to into the buildIndex method. This rewrite is a little shorter here in this already long method, and avoids an extra compare. We still get the benefit that we don\u0027t attempt to create the index until we have added at last 1000 items, but we avoid the extra branch for inQueue.",
      "revId": "5f02dd4fcacf690f80e7416ef16cabda2cbc232c",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOPX//9e0\u003d",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/revwalk/DateRevQueue.java",
        "patchSetId": 7
      },
      "lineNbr": 96,
      "author": {
        "id": 1
      },
      "writtenOn": "2013-02-22T17:49:38Z",
      "side": 1,
      "message": "What is the point of index[first] !\u003d null test?\n\nInitially the index is null so we never reach here. After a rebuild first points to a valid non-null entry.\n\nWhen next() runs it may advance first, but first still points to a valid index, provided that first \u003c\u003d last. The only time first isn\u0027t pointing at a non-null entry is when first \u003e last. In this case we also can\u0027t be sure first isn\u0027t \u003e index.length. If the array was sized exactly right then last \u003d\u003d index.length-1 and next() could advance first to be one past that when it pops the last index bucket. Now this array index operation will throw an exception.\n\nI think you want to write:\n\n  if (first \u003c\u003d last \u0026\u0026 index[first].commit.commitTime \u003e when)\n\nand modify the field initialization and clear() method to set last \u003d -1.",
      "revId": "5f02dd4fcacf690f80e7416ef16cabda2cbc232c",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOPX//9ew\u003d",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/revwalk/DateRevQueue.java",
        "patchSetId": 7
      },
      "lineNbr": 104,
      "author": {
        "id": 1
      },
      "writtenOn": "2013-02-22T17:49:38Z",
      "side": 1,
      "message": "no curly braces on this statement.",
      "revId": "5f02dd4fcacf690f80e7416ef16cabda2cbc232c",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOPX//9fw\u003d",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/revwalk/DateRevQueue.java",
        "patchSetId": 7
      },
      "lineNbr": 151,
      "author": {
        "id": 1
      },
      "writtenOn": "2013-02-22T17:49:38Z",
      "side": 1,
      "message": "style nit: I would phrase this loop as:\n\n  int qi \u003d 0, ii \u003d 0;\n  for (Entry q \u003d head; q !\u003d null; q \u003d q.next) {\n    if (++qi % 100 \u003d\u003d 0)\n      index[ii++] \u003d q;\n  }\n\nIts shorter by two lines because you can combine into the for loop. I know you have three \"iterators\" here, but I think its sane to use the for loop for the Entry pointer that is the main loop control variable. The other two \"iterators\" qi and ii aren\u0027t related to the number of iterations the loop makes so don\u0027t need to be in the for loop construct.",
      "revId": "5f02dd4fcacf690f80e7416ef16cabda2cbc232c",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
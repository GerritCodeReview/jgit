{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "120b48f0_f9350ce8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 10,
      "author": {
        "id": 150123
      },
      "writtenOn": "2022-10-21T22:49:12Z",
      "side": 1,
      "message": "I think we should promise precision - if we want to also use this for directory listings, precision would be useful. (I know that directory listings on the web are sometimes rounded to the nearest .1KiB or .1MiB, but things like VFS also need directory listings sometimes, and those need accurate sizes.)",
      "range": {
        "startLine": 10,
        "startChar": 8,
        "endLine": 10,
        "endChar": 17
      },
      "revId": "dc9289d1faaff41f4bb1c6728978e9d2387aab15",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f6d0b359_b746a805",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 14,
      "author": {
        "id": 150123
      },
      "writtenOn": "2022-10-21T22:49:12Z",
      "side": 1,
      "message": "What do we foresee V2 containing? Might be best just to say that we have a version number for forwards compatibility.",
      "range": {
        "startLine": 14,
        "startChar": 12,
        "endLine": 14,
        "endChar": 14
      },
      "revId": "dc9289d1faaff41f4bb1c6728978e9d2387aab15",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6229c99b_1053cd8f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 15,
      "author": {
        "id": 150123
      },
      "writtenOn": "2022-10-21T22:49:12Z",
      "side": 1,
      "message": "Below? I think it makes more sense that the ones below a threshold (which is the majority) have size information, whereas for the ones above, you have to check the object itself.",
      "range": {
        "startLine": 15,
        "startChar": 9,
        "endLine": 15,
        "endChar": 14
      },
      "revId": "dc9289d1faaff41f4bb1c6728978e9d2387aab15",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a93f48ba_e1923ba5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 18,
      "author": {
        "id": 150123
      },
      "writtenOn": "2022-10-21T22:49:12Z",
      "side": 1,
      "message": "All sizes are ultimately read from disk, so it\u0027s probably better to say that we can read all the sizes at once rather than having to seek in the packfile.",
      "range": {
        "startLine": 18,
        "startChar": 57,
        "endLine": 18,
        "endChar": 63
      },
      "revId": "dc9289d1faaff41f4bb1c6728978e9d2387aab15",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d720fd82_ab4e850a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 150123
      },
      "writtenOn": "2022-10-21T22:43:25Z",
      "side": 1,
      "message": "Taking a step back, we want to speed up partial clone by speeding up reading blob sizes. I think it is usually the case that a blob-size filter would allow most blobs through, so why can\u0027t we just optimistically read a block of the compressed object from disk (or network, if the packfile is on a network drive), check the size, and if the size is small enough, start the decompression from the block we read? The answer is that we want to do a pass through all the objects first for counting and size calculation for the purpose of progress reports, which is reasonable. We could just drop reporting progress altogether, but it\u0027s reassuring to the user, and this size index may later be useful for things like serving directory listings anyway.\n\nSo we want some sort of blob size cache that is contiguous on disk, so it can be read efficiently. That makes sense.\n",
      "revId": "dc9289d1faaff41f4bb1c6728978e9d2387aab15",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7392f153_aa071c90",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/PackObjectSizeIndex.java",
        "patchSetId": 8
      },
      "lineNbr": 16,
      "author": {
        "id": 150123
      },
      "writtenOn": "2022-10-21T22:49:12Z",
      "side": 1,
      "message": "Remember to update the javadoc depending on how the discussion over the commit message goes.\n\nAlso, if we do support approximate sizes, the interface needs to be more flexible (e.g. having a \"isNotLargerThan\" which can return \"yes\", \"no\", or \"unknown\").",
      "range": {
        "startLine": 16,
        "startChar": 45,
        "endLine": 16,
        "endChar": 49
      },
      "revId": "dc9289d1faaff41f4bb1c6728978e9d2387aab15",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "635fbf13_27f0bfc4",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/PackObjectSizeIndexV1.java",
        "patchSetId": 8
      },
      "lineNbr": 20,
      "author": {
        "id": 150123
      },
      "writtenOn": "2022-10-21T22:49:12Z",
      "side": 1,
      "message": "How big do the offsets and sizes get? If the offsets can fit in 5 bytes and the sizes in 3 bytes, I think you can save a lot of space (and no need separate storage for 32-bit and 64-bit). Also, why are we storing offsets? Can we store the place in the .idx file instead?",
      "range": {
        "startLine": 20,
        "startChar": 21,
        "endLine": 20,
        "endChar": 30
      },
      "revId": "dc9289d1faaff41f4bb1c6728978e9d2387aab15",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    }
  ]
}
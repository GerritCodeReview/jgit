{
  "comments": [
    {
      "key": {
        "uuid": "aa71e643_d3a78dd2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 27,
      "author": {
        "id": 5
      },
      "writtenOn": "2020-06-10T07:35:09Z",
      "side": 1,
      "message": "This statements confuses me a little bit. Do I get it right: with this patch set we are NOT adding code which would add \u0027000..\u0027 values to the index? Only if in the future all parties would accept \u0027000...\u0027 content as a marker for conflicts then we may concider writing such entries? Right?\n\nThat would be fine with me.\n\nI wanted to check native git behaviour, but I am not so sure how this \u0027ignoreConflicts\u0027 functionality is exposed. We use it mainly to have a common parent content to be displayed e.g. in gerrit ui when presenting conflicts, right? I tried with https://gist.github.com/chalstrick/ee18d33988d4751fbd640b2c035f61f9",
      "revId": "e005b3e5b2ef25d043bf2850ba4633fa68675789",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "52902677_53b1b2ec",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 27,
      "author": {
        "id": 256613
      },
      "writtenOn": "2020-06-11T00:09:58Z",
      "side": 1,
      "message": "\u003e\u003eDo I get it right\n\nYes, it is correct\n\n\u003e\u003eI wanted to check native git behaviour, but I am not so sure how this \u0027ignoreConflicts\u0027 functionality is exposed. \n\nIgnore conflict option in c-git is used when we want to use result in the next step of merge. jGit actually mimic c-git algorithm for the recursive merge as far as I can see.\n\nParticular case when we will get gitlink conflict is following:\n\nWe have 2 commits which we want to merge and they have ambiguous base parent. In order to merge them together we do it in 2 steps:\n1. Create a virtual parent commit \u003c- this is when ignoreConflict is used\n2. Merge these 2 commit with virtual commit used as `base`.\n\nSo in order to test submodule conflict with ignoreConflicts we should have the following commit tree:\n\nA    B\n|\\  /|\n| \\/ |\n| /\\ |\n|/  \\|\na    b\n|   /\n|  /\n| /\n|/\nz\n\nLet\u0027s assume \u0027A\u0027, \u0027B\u0027, \u0027a\u0027, \u0027b\u0027 and \u0027z\u0027 - are both name of commits and values of gitlink entry.\n\nThen if we do a recursive merge of \u0027A\u0027 and \u0027B\u0027 we will first try to create a virtual parent which is result for merging \u0027a\u0027 and \u0027b\u0027. It would be a simple 3-way merge with \u0027z\u0027 as a base. \n\nDuring this merge we won\u0027t be able to select a proper value for gitlink (both \u0027a\u0027 and \u0027b\u0027 is different from \u0027z\u0027, so both changes has updated a gitlink, we don\u0027t know which is the right one). If we just merged them without recursive merge we would have reported an error on this merge. However during recursive merge we\u0027re not reporting that kind of error, but instead we\u0027re creating a virtual parent, so our tree for the sake of algorithm looks like this:\n\nA     B\n \\   /\n  \\ / \n   v\n  / \\ \n /   \\\na     b\n|    /\n|   /\n|  /\n| /\n|/\nz\n\nwhere v - is the result of merge with ignoreConflicts \u003d true.\n\nWe will use v as a base for the second step of merge (another 3-way, but with ignoreConflicts \u003d false). So in order to inspect result of ignoreConflict \u003d true we have to catch state of v.\n\n\u003e\u003eI tried with \n\nI updated your instructions to trigger this workflow:\nhttps://gist.github.com/DemetrGoogle/c91a1799151e71ad1276775680256a2b\ndepends on state of subproject repos last command would or would not merge submodule.",
      "parentUuid": "aa71e643_d3a78dd2",
      "revId": "e005b3e5b2ef25d043bf2850ba4633fa68675789",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f7de991_d29099ac",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 27,
      "author": {
        "id": 5
      },
      "writtenOn": "2020-06-12T11:02:03Z",
      "side": 1,
      "message": "Ok, thanks, I got that.\nI remember having a similar discussion with Shawn when the first revision of RecursiveMerger was implemented. \nImagine the same situation for plain old java files. You are having the same commits as above but the content are blobs with java source code. Also in this case you try to create a intermediate parent z and sometimes you get conflicts when trying to create v. Back then I was asking: which content should we use in this case. a or b? The content in v can\u0027t be taken because it contains conflict markers \u0027\u003e\u003e\u003e\u0027,\u0027\u003c\u003c\u003c\u0027,\u0027\u003d\u003d\u003d\u0027 and is no valid java source code. I was shocked to hear: No, take the content with the conflict markers as base content. Take that invalid java source code as base content. And as we know now from experience is that this strategy works well, although the common base presented for conflicts is not even syntactical correct java code. So nobody can use the common base content as conflict resolution.\nWouldn\u0027t it be the same for gitlinks? Whats so bad if the common base content for a gitlink conflict is not syntactical correct but contains conflict markers? A base content in case of a gitlink conflict reported as: \n\n  \u003c\u003c\u003c\n  0033322344\n  \u003d\u003d\u003d\u003d\n  aacd33355\n  \u003e\u003e\u003e\n\nwould be ok for me and tells me to choose between these two commits for conflict resolution.\n\nOne reason not to got for this would be if the content with the conflict markers for a gitlink entry would cause bugs/exceptions. Is that the case?",
      "parentUuid": "52902677_53b1b2ec",
      "revId": "e005b3e5b2ef25d043bf2850ba4633fa68675789",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f917db2_4de6f6bd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 27,
      "author": {
        "id": 256613
      },
      "writtenOn": "2020-06-12T21:45:47Z",
      "side": 1,
      "message": "\u003e\u003e would be ok for me and tells me to choose between these two commits for conflict resolution.\n\nIt would be ok for me as well, but unfortunately it is not an option. Blob that contain conflict markers is still a correct blob, but gitlink is not a blob, it can contain only one objectId. So we can\u0027t save conflict markers in the same file.\n\nThere are other options considered:\n1. Convert it to a blob and populate merge conflict information\n2. Create another entry for conflicted value (aka gitlink.conflict_ours)\n\nThis 2 options would have provided additional information, but we can\u0027t use them, because it make overall repo inconsistent (gitlinks should match .gitmodules). And it should be consistent between different git implementation as well.\n\nThat is why we can select only one valid objectId at the moment.",
      "parentUuid": "3f7de991_d29099ac",
      "revId": "e005b3e5b2ef25d043bf2850ba4633fa68675789",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
{
  "comments": [
    {
      "key": {
        "uuid": "AABOG3//9Rw\u003d",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/api/HugeFileTest.java",
        "patchSetId": 1
      },
      "lineNbr": 2,
      "author": {
        "id": 4
      },
      "writtenOn": "2012-04-15T23:44:29Z",
      "side": 1,
      "message": "I guess this should be your copyright",
      "revId": "f65359d33315d59729b9b4e51c6f4779473acb92",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOG3//9R8\u003d",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/api/HugeFileTest.java",
        "patchSetId": 1
      },
      "lineNbr": 74,
      "author": {
        "id": 1
      },
      "writtenOn": "2012-04-15T18:13:37Z",
      "side": 1,
      "message": "I wish I had a good answer for how to avoid doing operations like a SHA-1 on 4G of data.\n\nMaybe a custom subclass of WorkTreeIterator that provides a single fake huge file and returns a fake ObjectId that is cached, thus avoiding the need to run SHA-1 over the input stream?",
      "revId": "f65359d33315d59729b9b4e51c6f4779473acb92",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOG3//9Rs\u003d",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/api/HugeFileTest.java",
        "patchSetId": 1
      },
      "lineNbr": 74,
      "author": {
        "id": 8
      },
      "writtenOn": "2012-04-15T20:11:27Z",
      "side": 1,
      "message": "I am a little worried some optimization may bypass the modulo nature of the dircache length attribute and not read everyting. \n\nMocking some operation with mockito may be better, because we could then verify that the correct calls would have been made.",
      "parentUuid": "AABOG3//9R8\u003d",
      "revId": "f65359d33315d59729b9b4e51c6f4779473acb92",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOG3//9Rk\u003d",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/api/HugeFileTest.java",
        "patchSetId": 1
      },
      "lineNbr": 74,
      "author": {
        "id": 8
      },
      "writtenOn": "2012-04-15T23:15:57Z",
      "side": 1,
      "message": "tmpfs and lots of RAM would help. This is an essentially IO-bound operation. On my laptop raw dd runs at about 65 MB/s, while the Add opertions slows down, but only to around 55. An infinitely fast SHA-1 would only gain about 10 seconds. I tried http://www.saphir2.com/sphlib/, but the difference is drowned by measuring errors.",
      "parentUuid": "AABOG3//9Rs\u003d",
      "revId": "f65359d33315d59729b9b4e51c6f4779473acb92",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOG3//9Rc\u003d",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/api/HugeFileTest.java",
        "patchSetId": 1
      },
      "lineNbr": 74,
      "author": {
        "id": 1
      },
      "writtenOn": "2012-04-15T23:31:41Z",
      "side": 1,
      "message": "I\u0027m not thrilled about adding 40 seconds or whatever to our unit testing time just to verify we truncate a long to an int the way git-core does. It would be better to mock out this \u003e4G test somewhat so we aren\u0027t asking the local system to deal with a 4G temporary file in the middle of what should be small fast unit test.",
      "parentUuid": "AABOG3//9Rk\u003d",
      "revId": "f65359d33315d59729b9b4e51c6f4779473acb92",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
{
  "comments": [
    {
      "key": {
        "uuid": "67306a88_3b26d56a",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 1
      },
      "lineNbr": 389,
      "author": {
        "id": 44628
      },
      "writtenOn": "2018-08-17T16:07:48Z",
      "side": 1,
      "message": "Honestly said, I don\u0027t quite get the logic here. You want to catch the case where two processes/threads get true from createNewFile(\"foo\"). To do so you create a hard link and then check whether nlink \u003d\u003d 2. So both create (\"foo.lnk\"). Is that atomic? Or can both succeed? If both succeed, they will also both get nlink \u003d\u003d 2, won\u0027t they?\n\nThe recommendation for this technique was that each client should create a link with a unique file name, including hostname \u0026 pid or some such. Then I can understand it... kind of. Presumably a sequence like\n\n  A : createNewFile(\"foo\") -\u003e true\n  B : createNewFile(\"foo\") -\u003e true\n  A : createLink(\"foo.lnk_a_unique_id\") -\u003e OK\n  A : getAttribute(\"foo\", \"unix:nlink\") -\u003e 2\n  A : delete(\"foo.lnk_a_unique_id\")\n  B : createLink(\"foo.lnk_b_unique_id\") -\u003e OK\n  B : getAttribute(\"foo\", \"unix:nlink\") -\u003e 2\n  B : delete(\"foo.lnk_b_unique_id\")\n\ncannot occur? But I don\u0027t see why not... Methinks the algorithm can work only if\n\n1. link names have indeed a unique id,\n2. and are kept for as long as the file is kept",
      "revId": "b80cb69f93d7832323bbb20d266d8d814692615d",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8954a1ba_76c49785",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 1
      },
      "lineNbr": 389,
      "author": {
        "id": 5
      },
      "writtenOn": "2018-08-24T16:10:51Z",
      "side": 1,
      "message": "Hmmm, I think you are right. I read open(2) man page and agree we have to use a unique name for the hard link. That could be achieved by just adding UUID.randomUUID() to the link name.\n\nBut keeping the link as long as the lock file maybe more tricky. Maybe we need to add something to LockFile like deleteOnUnlock(File x) to tell which additional files to delete on unlock. Any comments?",
      "parentUuid": "67306a88_3b26d56a",
      "revId": "b80cb69f93d7832323bbb20d266d8d814692615d",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0d1e0c64_d9f33541",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 1
      },
      "lineNbr": 389,
      "author": {
        "id": 44628
      },
      "writtenOn": "2018-08-24T17:20:24Z",
      "side": 1,
      "message": "FS.createNewFile() is used _only_ in LockFile.lock(). So I would just deprecate this and add a new version that returns the hard-link \"File\" when successful, or null if not. Then use that.\n\nThen we can store that hard-link File in LockFile.lock(), and delete it when we unlock the lock.\n\nFor the static Lock::unlock, we could use a naming convention such that we can delete stale hard links, too.\n\nWhen we don\u0027t do this hard-link mechanism, just return the lock file itself. LockFile.unlock (either version) may then try to delete that file twice, so it must not fail if that second file doesn\u0027t exist.\n\nWhatever \"unique ID\" we add it shouldn\u0027t be overly long, lest we hit fancy filename length limits. (OK, we do this only on POSIX, so probably not an issue.) The \"unique ID\" format in the file name for the hard link must be such that it cannot conflict with other non-hard-link files.\n\nAnyway I think the branch name validations currently only forbid a trailing \".lock\". If you have two branches \"foo\" and \"foo.lock.lnk\",  the current mechanism may already get into trouble. Don\u0027t know yet how to deal with that...",
      "parentUuid": "8954a1ba_76c49785",
      "revId": "b80cb69f93d7832323bbb20d266d8d814692615d",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a466d0c_68650bab",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 1
      },
      "lineNbr": 389,
      "author": {
        "id": 44628
      },
      "writtenOn": "2018-08-24T17:23:35Z",
      "side": 1,
      "message": "That said, I would do this on master. Here on stable-5.0, just add the missing {} and then we can merge this. Apparently the current algorithm is good enough for your use case; properly fixing it can be done later on master.",
      "parentUuid": "0d1e0c64_d9f33541",
      "revId": "b80cb69f93d7832323bbb20d266d8d814692615d",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d3e36fde_ae3f8e81",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/util/FS_POSIX.java",
        "patchSetId": 1
      },
      "lineNbr": 405,
      "author": {
        "id": 44628
      },
      "writtenOn": "2018-08-17T16:07:48Z",
      "side": 1,
      "message": "Missing {}",
      "revId": "b80cb69f93d7832323bbb20d266d8d814692615d",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}